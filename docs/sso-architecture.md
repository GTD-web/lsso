
# SSO 아키텍처 설계 문서

## 1. 아키텍처 개요

이 시스템은 SSO 서버를 중앙 인증 서버로 구성하여, 채용관리 시스템과 자원관리 시스템이 각각 사용자 인증을 요청하고, 인증된 결과를 공유하는 구조입니다. JWT를 사용한 인증 토큰 발급 방식으로, Redis를 통해 토큰 상태(로그아웃 처리 등)를 관리하며, Redis 접근은 SSO 서버를 통해서만 수행하거나, 각 시스템에서 읽기 전용으로 접근할 수 있도록 구성할 수 있습니다.

## 2. 주요 컴포넌트

- **사용자**: 웹 브라우저에서 채용관리 또는 자원관리 시스템에 직접 로그인 시도
- **채용관리 시스템 / 자원관리 시스템**: 사용자 로그인 요청을 받아 SSO 서버에 위임하여 인증을 수행
- **SSO 시스템**:
  - 로그인 요청을 받아 사용자 정보를 검증하고 JWT를 발급
  - JWT는 매 로그인 시 새로운 서명 키(Secret 또는 Key ID 기반 서명 키)로 서명됨
  - 해당 키와 만료일을 포함한 정보가 시스템에 전달되어 자체 검증 가능
  - Refresh Token도 함께 발급되어 액세스 토큰 만료 후 재발급 요청 가능
  - 로그아웃 요청 시 Redis에 해당 토큰을 블랙리스트로 등록
  - JWT 서명을 위한 키 관리 및 회전을 내부적으로 수행하며, 키 매핑은 SSO에서 관리
  - 외부 시스템 등록 및 검증 기능 포함 (아래 9장 참고)
- **Redis**: JWT 블랙리스트 저장소로 사용되며, 읽기 권한은 각 시스템에 부여하여 블랙리스트 상태를 직접 조회할 수 있도록 구성함

## 3. 인증 흐름

1. 사용자가 채용관리 시스템 또는 자원관리 시스템에서 로그인 폼 입력
2. 해당 시스템이 사용자 로그인 정보를 SSO 서버로 전달 (API 호출)
3. SSO 서버가 사용자 인증 → JWT 및 Refresh Token 발급
4. JWT는 새로운 서명 키(예: key-id-123)로 서명되며, 해당 key 정보와 만료일도 함께 응답
5. 시스템은 JWT, Refresh Token, Key ID, Key 만료일을 저장하여 자체 인증 처리
6. 이후 모든 API 요청 시 JWT를 포함하여 처리하며, SSO 서버에 의존하지 않고 자체 검증 수행
7. JWT 만료 전이라면 해당 Key를 사용하여 검증, 만료 후에는 Refresh Token으로 토큰 재발급 요청
8. 각 시스템은 JWT 유효성 검증 시 Redis의 블랙리스트를 조회하여 해당 토큰의 로그아웃 여부를 확인

## 4. 로그아웃 흐름

1. 사용자가 채용관리 또는 자원관리 시스템에서 로그아웃 시도
2. 해당 시스템이 SSO 서버에 로그아웃 요청 전달 (JWT 포함)
3. SSO 서버는 해당 JWT를 Redis에 블랙리스트로 등록
4. 이후 해당 토큰은 무효화됨 → 다른 시스템에서도 더 이상 사용 불가
5. 각 시스템은 요청 처리 시 Redis 블랙리스트 확인을 통해 토큰 무효 여부 판단
6. **Webhook 기반 로그아웃 이벤트 전파는 선택 기능으로 추가 가능**
   - 이 기능을 통해 SSO 서버가 로그아웃 이벤트 발생 시 각 시스템에 사용자 세션 종료를 알릴 수 있음
   - 실시간 로그아웃 반영 또는 캐시 제거 등 보조적인 수단으로 활용 가능

## 5. 시스템 간 도식화

```
[User]
  | Login
  v
[Recruitment System]   [Resource System]
        |                     |
        | API 요청            | API 요청
        |                     |
        v                     v
JWT + KeyID + Refresh 발급   JWT + KeyID + Refresh 발급
        \____________________/
                  |
           [SSO System] <-> Redis
            |   |   |
     Key 관리  발급  블랙리스트 저장
             |
           Webhook (선택 기능)
```

## 6. 설계 의도 검토 및 피드백

### ✅ 적절한 설계 포인트:
- 인증 전용 서버(SSO)로 단일 인증 로직 유지 → 각 시스템에서 인증 로직 중복 제거
- JWT 사용으로 stateless 인증 구현 가능
- 각 시스템에서 JWT 유효성 자체 검증 → 성능 향상 및 의존성 감소
- Redis는 블랙리스트 확인 용도로 각 시스템에서 읽기 가능 → 로그아웃 즉시 반영 가능
- Key를 매 로그인 시 발급하여 보안성과 유연성 향상
- Refresh Token 구조로 사용자 경험 향상 및 세션 유지 가능
- Webhook을 통한 로그아웃 동기화는 선택적으로 적용 가능

### ⚠️ 고려사항:
- Key 발급/회전/만료 정책을 명확히 정의해야 함
- 각 시스템은 Key 만료 시점에 따른 토큰 검증 실패 대비 필요
- Refresh Token 유출 시 리스크 존재 → 보안 저장 및 짧은 유효 기간 설정 권장
- Redis 연결 설정 시 네트워크 접근 제어 및 인증 철저히 구성 필요
- Webhook 도입 시 호출 실패 대응 로직 필요

## 7. 확장 가능성
- OIDC 기반으로 확장하여 외부 IDP 연동 (Google, Azure AD 등)
- Webhook 기반으로 시스템 간 로그아웃 동기화
- JWT 서명을 위한 키를 Key Management System(KMS)에서 관리
- 키 관리 정책 자동화 (예: 하루 1회 회전, 만료 후 자동 폐기)

## 8. 요약
이 구조는 SSO 시스템을 중심으로 한 JWT 기반 인증 연동 구조로, 각 시스템의 로그인 흐름을 통합하되 UI는 분리하며, Redis를 활용한 중앙 토큰 상태 관리를 특징으로 합니다. JWT는 각 로그인 요청 시 고유 서명 키로 발급되며, 각 시스템은 해당 키 유효 기간 동안 자체적으로 토큰을 검증합니다. 만료 시에는 Refresh Token을 통해 새로운 액세스 토큰을 발급받아 SSO 서버와의 의존을 최소화하면서도 보안성과 확장성을 모두 확보할 수 있는 구조입니다.
또한 각 시스템은 Redis 블랙리스트를 직접 조회하여 토큰 무효화를 판단하고, Webhook 방식은 선택적으로 도입하여 로그아웃 동기화를 강화할 수 있습니다.

## 9. 외부 시스템 등록 및 인증 검증

SSO 시스템은 각 외부 시스템이 인증 요청을 하기 전에 등록 과정을 통해 인가된 시스템임을 확인할 수 있어야 합니다. 이를 위해 아래와 같은 등록 정보가 필요합니다.

### 등록 시 입력 정보
- **시스템 이름**: 채용관리시스템, 자원관리시스템 등 식별 가능한 이름
- **도메인**: 요청이 발생하는 서버의 도메인 (개발 환경에서는 localhost 허용)
- **설명**: 시스템의 간략한 설명 또는 용도
- **Webhook URL (선택)**: 로그아웃 이벤트를 수신할 수 있는 URL

### 등록 후 발급
- **시스템 식별자 (System ID)**
- **시크릿 키 (System Secret)**: 외부에 노출되어선 안 되는 고유 키. API 요청 시 서명에 사용됨

각 시스템은 이 키를 `.env` 등에 보관하고 SSO 요청 시 인증 헤더 또는 서명용 파라미터로 포함시켜야 합니다. 이 값은 단일 시스템의 식별 및 위조 방지를 위해 사용됩니다.

### 시스템 검증 흐름 예시
1. 각 시스템은 로그인/토큰 요청 시 System ID와 Secret을 함께 포함
2. SSO 서버는 등록된 정보와 비교하여 유효성 검증 수행
3. 실패 시 요청 거부 및 보안 이벤트 기록

이렇게 함으로써, 등록된 시스템만 인증 요청을 보낼 수 있도록 보장하며, 무단 접근을 차단할 수 있습니다.
